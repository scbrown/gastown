description = "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion ‚Äî sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí idle (sandbox preserved)\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked ‚Äî its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers merge flow registration\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail)."
formula = 'mol-witness-patrol'
version = 6

[vars]
[vars.wisp_type]
description = "Type of wisp created for this molecule"
default = "patrol"

[[steps]]
description = "First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state ‚Äî its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí idle (preserved)\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\n‚ö†Ô∏è **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY ‚Üí archive mail\n# - Without MR: acknowledge ‚Üí archive mail\n# - Polecat goes idle in BOTH cases ‚Äî no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE. The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:<name>,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close <wisp-id> --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty."
id = 'inbox-check'
title = 'Process witness mail'

[[steps]]
description = "Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution."
id = 'process-cleanups'
needs = ['inbox-check']
title = 'Process pending cleanup wisps'

[[steps]]
description = "Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status <rig>/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=<N>\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue ‚Äî there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n‚ö†Ô∏è **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2>/dev/null && echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: <summary>\" \\\n  -m \"MR IDs: <ids>\nObservation: <what you found>\nRecommendation: <what should happen>\"\n```"
id = 'check-refinery'
needs = ['process-cleanups']
title = 'Check refinery and deacon health'

[[steps]]
description = "Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION ‚Äî Cross-reference tmux session existence**\n\nüö® **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status <rig>/<name> --json | jq -r '.running' | grep -q true && echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show <hook_bead> --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session ‚Äî do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/<name>/<rig>\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:<name>,state:merge-requested --status=open\n# If merge-requested wisp exists ‚Üí DO NOT NUKE, MR pending in refinery\n# If no pending MR ‚Üí safe to nuke (zombie with no work to preserve)\ngt polecat nuke <name>\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED <rig>/<name>\" \\\n  -m \"Polecat: <rig>/<name>\nCleanup Status: <has_uncommitted|has_unpushed|has_stash>\nHook Bead: <hook_bead>\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=<state>.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:<name>\" \\\n  --description \"Zombie detected: session dead, state=<agent_state>\" \\\n  --labels cleanup,polecat:<name>,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek <rig>/<name> 20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Idle at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n‚ö†Ô∏è **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs ‚Äî an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:<name>,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke ‚Äî the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: idle (no hook_bead)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE ‚Äî handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:<name>,state:merge-requested --status=open\n   # If no pending MR and no dirty state ‚Üí polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie ‚Äî the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION ‚Äî Scan from beads side**\n\nüö® **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `<rig>/polecats/<name>`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip ‚Äî the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status <rig>/<name> --json | jq -r '.running'`\n3. Check polecat directory: `ls <rig>/polecats/<name> 2>/dev/null`\n4. If BOTH session dead AND directory missing ‚Üí orphan. Reset the bead:\n   ```bash\n   bd update <bead-id> --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: <bead-id>\" \\\n     -m \"Bead <bead-id> was assigned to <rig>/polecats/<name> which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead ‚Üí skip (zombie detection handles it)\n6. If session alive ‚Üí not an orphan, skip"
id = 'survey-workers'
needs = ['check-refinery']
title = 'Inspect all active polecats'

[[steps]]
description = "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed."
id = 'check-timer-gates'
needs = ['survey-workers']
title = 'Check timer gates for expiration'

[[steps]]
description = "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete."
id = 'check-swarm-completion'
needs = ['check-timer-gates']
title = 'Check if active swarm is complete'

[[steps]]
description = "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was processed (cleanup wisp created) ‚Üí archive\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare."
id = 'patrol-cleanup'
needs = ['check-swarm-completion']
title = 'End-of-cycle inbox hygiene'

[[steps]]
description = "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling"
id = 'context-check'
needs = ['patrol-cleanup']
title = 'Check own context limit'

[[steps]]
description = "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `<YOUR_RIG>` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: <YOUR_RIG>\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error ‚Äî verify you substituted `<YOUR_RIG>` correctly. If it returns multiple results, STOP and report an error ‚Äî manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"<patrol-summary>\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=<rig>/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook."
id = 'loop-or-exit'
needs = ['context-check']
title = 'Loop or exit for respawn'
